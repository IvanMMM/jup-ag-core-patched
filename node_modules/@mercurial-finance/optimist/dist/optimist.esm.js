import { SystemProgram, PublicKey } from '@solana/web3.js';
import { AccountLayout, u64 } from '@solana/spl-token';

class TransactionError extends Error {
  constructor(m, txid, code) {
    super(m);
    this.txid = void 0;
    this.code = void 0;
    this.txid = txid;
    this.code = code; // Set the prototype explicitly.

    Object.setPrototypeOf(this, Error.prototype);
  }

}
const UNKNOWN_ERROR = 'Unknown error, visit the explorer';
async function parseErrorForTransaction(tx) {
  var _tx$meta;

  // Easy case, logMessages has an obvious error message. From dapp-scaffold
  const errors = [];

  if (tx !== null && tx !== void 0 && tx.meta && tx.meta.logMessages) {
    tx.meta.logMessages.forEach(log => {
      const regex = /Error: (.*)/gm;
      let m;

      while ((m = regex.exec(log)) !== null) {
        // This is necessary to avoid infinite loops with zero-width matches
        if (m.index === regex.lastIndex) {
          regex.lastIndex++;
        }

        if (m.length > 1) {
          errors.push(m[1]);
        }
      }
    });
  }

  if (errors.length > 0) {
    return {
      message: errors.join(',')
    };
  } // Harder case, we need to dig for a custom code


  const transactionError = tx === null || tx === void 0 ? void 0 : (_tx$meta = tx.meta) === null || _tx$meta === void 0 ? void 0 : _tx$meta.err;
  const transactionErrorString = JSON.stringify(transactionError);
  let errorCode;

  if (transactionError && typeof transactionError !== 'string') {
    var _tx$meta2;

    const instructionError = transactionError.InstructionError;
    const [index, {
      Custom
    }] = instructionError;
    errorCode = Custom; // We have found what caused the error so we can map it

    const innerInstructions = tx === null || tx === void 0 ? void 0 : (_tx$meta2 = tx.meta) === null || _tx$meta2 === void 0 ? void 0 : _tx$meta2.innerInstructions;

    if (!innerInstructions || index >= innerInstructions.length) {
      var _tx$meta3;

      if (tx !== null && tx !== void 0 && tx.meta && tx.meta.logMessages && isSystemProgram((_tx$meta3 = tx.meta) === null || _tx$meta3 === void 0 ? void 0 : _tx$meta3.logMessages)) {
        return getSystemProgramError(instructionError);
      }

      return {
        message: transactionErrorString,
        code: errorCode
      };
    }

    const innerInstruction = innerInstructions.find(innerIx => innerIx.index === index);

    if (!innerInstruction) {
      return {
        message: transactionErrorString,
        code: errorCode
      };
    }

    const programIdIndex = innerInstruction.instructions[innerInstruction.instructions.length - 1].programIdIndex;
    const programId = tx.transaction.message.accountKeys[programIdIndex];

    if (programId.equals(SystemProgram.programId)) {
      return getSystemProgramError(instructionError);
    }
  }

  return {
    message: typeof transactionError === 'string' ? transactionError : UNKNOWN_ERROR,
    code: errorCode
  };
}

function isSystemProgram(logMessages) {
  logMessages.forEach(log => {
    if (log.includes('Program 11111111111111111111111111111111 invoke')) return true;
  });
  return false;
}

async function getSystemProgramError(instructionError) {
  const code = instructionError[1].Custom;
  let message = '';

  switch (code) {
    // https://github.com/solana-labs/solana/blob/22a18a68e3ee68ae013d647e62e12128433d7230/sdk/program/src/system_instruction.rs#L12-L26
    // TODO: Do we need to translate all error codes.
    case 0:
      message = 'An account with the same address already exists';

    case 1:
      message = 'The account does not have enough SOL to perform the operation';

    default:
      message = UNKNOWN_ERROR;
  }

  return {
    code,
    message
  };
}

const deserializeAccount = data => {
  if (data == undefined || data.length == 0) {
    return undefined;
  }

  const accountInfo = AccountLayout.decode(data);
  accountInfo.mint = new PublicKey(accountInfo.mint);
  accountInfo.owner = new PublicKey(accountInfo.owner);
  accountInfo.amount = u64.fromBuffer(accountInfo.amount);

  if (accountInfo.delegateOption === 0) {
    accountInfo.delegate = null;
    accountInfo.delegatedAmount = new u64(0);
  } else {
    accountInfo.delegate = new PublicKey(accountInfo.delegate);
    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);
  }

  accountInfo.isInitialized = accountInfo.state !== 0;
  accountInfo.isFrozen = accountInfo.state === 2;

  if (accountInfo.isNativeOption === 1) {
    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);
    accountInfo.isNative = true;
  } else {
    accountInfo.rentExemptReserve = null;
    accountInfo.isNative = false;
  }

  if (accountInfo.closeAuthorityOption === 0) {
    accountInfo.closeAuthority = null;
  } else {
    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);
  }

  return accountInfo;
};

export { TransactionError, UNKNOWN_ERROR, deserializeAccount, parseErrorForTransaction };
//# sourceMappingURL=optimist.esm.js.map
